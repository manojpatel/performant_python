import time
from functools import lru_cache
from typing import Any, cast

import tantivy
from minijinja import Environment
from opentelemetry import trace

tracer = trace.get_tracer("performant-python.extras")

# --- MiniJinja Setup (Templating) ---
jinja_env = Environment()
jinja_env.add_template(
    "report.html",
    """
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Performance Report: {{ batch_id }}</title>
</head>
<body>
    <h1>Processing Results for {{ batch_id }}</h1>
    <p>Processed {{ total_records }} records in {{ duration_ms }} ms.</p>
    <ul>
    {% for category, val in by_category.items() %}
        <li><strong>{{ category }}:</strong> {{ val }}</li>
    {% endfor %}
    </ul>
    <footer>Generated by MiniJinja (Rust)</footer>
</body>
</html>
""",
)


@tracer.start_as_current_span("render_report")
def render_report(context: dict[str, Any]) -> str:
    """
    Renders a template using MiniJinja (Rust).
    """
    return jinja_env.render_template("report.html", **context)  # type: ignore[no-any-return]


# --- Tantivy Setup (Search) ---
class SearchEngine:
    _instance = None

    def __init__(self) -> None:
        # We create an in-memory index for demonstration
        schema_builder = tantivy.SchemaBuilder()
        schema_builder.add_text_field("title", stored=True)
        schema_builder.add_text_field("body", stored=True)
        schema_builder.add_integer_field("id", stored=True)
        self.schema = schema_builder.build()

        # Create index in RAM
        self.index = tantivy.Index(self.schema)
        self.writer = self.index.writer()

    @classmethod
    def get_instance(cls) -> "SearchEngine":
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance

    @tracer.start_as_current_span("tantivy_seed")
    def seed(self, size: int = 10000) -> None:
        """
        Seeds the Tantivy index with dummy documents.
        """
        print(f"Indexing {size} documents into Tantivy...")
        start = time.time()
        for i in range(size):
            title = f"Doc {i} - Performance Optimization"
            body = (
                f"This is the body of document {i}. "
                f"It mentions Rust, Python, and Speed. The number is {i}."
            )
            if i % 2 == 0:
                body += " It also talks about Databases."

            doc = tantivy.Document()
            doc.add_text("title", title)
            doc.add_text("body", body)
            doc.add_unsigned("id", i)
            self.writer.add_document(doc)

        with tracer.start_as_current_span("tantivy_commit"):
            self.writer.commit()

        # Index is now ready for searching (searcher created on-demand in search method)
        print(f"Indexing complete in {time.time() - start:.4f}s")

    @lru_cache(maxsize=256)  # noqa: B019
    @tracer.start_as_current_span("search")
    def search(self, query: str, limit: int = 10) -> list[dict[str, Any]]:
        """
        Searches the index using Tantivy (Rust).
        Cached for performance - repeated searches return instantly.
        """
        with tracer.start_as_current_span("tantivy_execute_search"):
            searcher = self.index.searcher()
            # Tantivy 0.22+ API: parse_query is now a method on Index
            query_obj = self.index.parse_query(query, ["title", "body"])

            top_docs = searcher.search(query_obj, limit).hits

        results = []
        for _, doc_address in top_docs:
            retrieved_doc = searcher.doc(doc_address)
            # Cast to dict behavior or Any to bypass MyPy checks on native object
            doc_any = cast(Any, retrieved_doc)
            results.append(
                {
                    "id": doc_any["id"][0],
                    "title": doc_any.get("title", [""])[0],
                    "body": doc_any.get("body", [""])[0][:200],  # truncate
                }
            )

        return results
